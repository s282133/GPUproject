#include <stdio.h>

#define N_BLOCKS 10
#define N_THREADS 4

typedef struct {
    unsigned long int N;        // p * q = N, but p and q are two UNKNOWN primes
}   RSA_keyType;

typedef struct {
    unsigned long int N;        // you can ONLY access this field in PUBLIC KEYS !
    unsigned long int p;        // you cannot access this field in PUBLIC KEYS !
    unsigned long int q;        // you cannot access this field  In PUBLIC KEYS !
} RSA_decrypted_KeyType;


int main(void){

    int i = 0;
    int PublicKeysNum = 100; 
    int decryptedKeysNum;
    RSA_keyType* publicKeys;
    RSA_keyType* publicKeys_dev;
    RSA_decrypted_KeyType* decryptedN_publicKeys;
    RSA_decrypted_KeyType* decryptedN_publicKeys_dev;

    publicKeys = (RSA_keyType*)malloc(PublicKeysNum * sizeof(RSA_keyType));
    decryptedN_publicKeys = (RSA_decrypted_KeyType*)malloc(PublicKeysNum * sizeof(RSA_decrypted_KeyType));

    // initialize publicKeys to the random numbers generated by the random number "n" generator
    for(i = 0; i < PublicKeysNum; i++){
        decryptedN_publicKeys[i].N = 0;
        decryptedN_publicKeys[i].p = 0;
        decryptedN_publicKeys[i].q = 0;
    }

    // allocate dynamic memory for the publicKeys array on the device and for decryptedN_publicKeys on the device 
    cudaMalloc((void**) &publicKeys_dev, PublicKeysNum * sizeof(RSA_keyType));
    cudaMalloc((void**) &decryptedN_publicKeys_dev, PublicKeysNum * sizeof(RSA_decrypted_KeyType));     // sovradimensionato sulla GPU
    cudaMalloc((void**) &decryptedKeysNum, sizeof(int));                                                // number of decrypted keys thanks to the GPU

    // copy the publicKeys array to the device
    cudaMemcpy(publicKeys_dev, publicKeys, PublicKeysNum * sizeof(RSA_keyType), cudaMemcpyHostToDevice);

    // kernel function call
    kernel<<<N_BLOCKS, N_THREADS>>>(publicKeys_dev, decryptedN_publicKeys_dev, PublicKeysNum);   
    
    // copy the decryptedN_publicKeys array from the device to the host
    cudaMemcpy(decryptedN_publicKeys, decryptedN_publicKeys_dev, PublicKeysNum * sizeof(RSA_decrypted_KeyType), cudaMemcpyDeviceToHost);
    
    // print the decryptedN_publicKeys array
    for(i = 0; i < decryptedKeusNum; i++){
        printf("decryptedN_publicKeys[%d] = %lu\n", i, decryptedN_publicKeys[i].N);
        printf("decryptedN_publicKeys[%d] = %lu\n", i, decryptedN_publicKeys[i].p);
        printf("decryptedN_publicKeys[%d] = %lu\n", i, decryptedN_publicKeys[i].q);
        printf("\n");
    }

}


int kernel(RSA_keyType* n_keys, RSA_decrypted_KeyType* decryptedN_publicKeys, int PublicKeysNum, int decryptedKeysNum){

    int tid, i, j;
    unsigned long int a, b, r;

    tid = blockIdx.x * blockDim.x + threadIdx.x;

    i = tid / PublicKeysNum;

    j = tid % PublicKeysNum;

    if(j > i){
        // GCD between n_keys[i] and n_keys[j]
        a = n_keys[i];
        b = n_keys[j];

        while(b > 0){
            r = a % b;
            a = b;
            b = r;
        }   // if GCD is 1, then n_keys[i] and n_keys[j] are coprime

        if(a > 1) { // a and b share a common factor 
            decryptedN_publicKeys[j].N = n_keys[i];
            decryptedN_publicKeys[j].p = a;
            decryptedN_publicKeys[j].q = n_keys[i] / a;
        }
        

    }

}